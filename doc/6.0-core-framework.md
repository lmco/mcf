# MBEE Core Framework

## Code Structure

MBEE is built using an MVC (Model/View/Controller) architecture. For those who
are not as familiar with this type of architecture, the code is divided up into
separate models (which house database schemas), controllers (which house code
for interacting with the models), and views (which house code for interacting
with objects created through the models and controllers).

Each primary component of the MBEE architecture has it's own model, view and
controller. For example, there is an element model, element controller and
element view.

#### Models

Models handle all data-related logic. In the case of MBEE, the models define
schemas and export them. Models are very similar to classes in normal
object-oriented programming. Models define a data structure which can be used
as a template to create a document. Models can additionally have functions
attached. In the case of the element model, functions such as
`getValidUpdateFields()` and `getValidPopulateFields()` are attached to the
model and can be called on an instance (document) of that model or can be
called using the model directly.

Each model also defines functions for interacting with the database. As we are
using mongoose, these functions are pre-defined for us and are exported
automatically with the model. You can read more about the mongoose model
functions in the [Mongoose documentation](https://mongoosejs.com/docs/guide.html).

#### Controllers

Controllers interact with the model directly, and define CRUD operations which
get used in the views. Each controller imports it's respective model, and uses
that model to manipulate data. Each controller in MBEE defines functions for
finding, creating, replacing, updating and deleting documents from the database.
The controllers preform additional logic to validate provided data.
For example, the element controller preforms logic on delete that ensures the
user is not trying to delete the root model element.

#### Views

Views are UI components that directly interact with models and controllers,
usually through an API. In the case of MBEE, the views call API functions which
in turn call controller functions, which use the models to manipulate data.

## The "M" Object

The M object is a global object which is accessible across the entire code base.
It contains valuable information and operations which are easier to attach to
the object, rather than import in every location needed. The M object is created
upon server startup, and is locked from modification immediately, so do not
attempt to change fields or add your own fields. The following information is
provided in the M object and is accessible any place in the root directory
(including plugins).

- **env:** Provides the current running environment (as a string). If no
  environment was specified upon startup, the *default* environment is used.
- **version:** Provides the current version of MBEE. This value can be found in
  the package.json.
- **build:** Provides the build number found in the package.json. If none is
  specified, it defaults to *NO_BUILD_NUMBER*.
- **schemaVersion:** Provides the schemaVersion, found in the package.json.
- **require():** Provides a simplified function for importing files within the
  */app* directory. This can be used by providing the path within the app
  directory, and separating the directories using dot notation.
  Example for /app/models/element.js:
  `const Element = M.require('models.element');`
- **getModuleName():** Provides a function which returns the module name.
- **root:** Provides a path to the root directory. This can be used to access
  files within the root directory, no matter where that directory is located.
- **config:** Provides an object which contains all key/value pairs from the
  running config.
- **log():** Provides a function for logging information to the console. Can
  also be used to log information and errors to .log files. See the log section
  below for more information.
- **CustomError():** Provides access to the CustomError class. CustomErrors are
  used throughout the code to organize errors. The CustomError constructor
  expects three parameters, the error message, HTTP status code and log level.

## Logger

Built into the global M object is a very useful logger. It has the ability to
print information to the console at different log levels (and colors), as well
as log information to .log files. There are 6 log levels, listed in order from
least important to most important: debug, verbose, info, warn, error, and
critical. If we wanted to log some information to the console, we could
simply do it by calling `M.log.info('Your info here');`.

There are three .log files created by default, each of which contain different
information. The first is `mbee-debug.log`. This file contains anything and
everything which has been logged. The next file is `mbee.log`, which contains
anything that has been logged at or above the level specified in the log.level
section of the running config. The final log file is `mbee-error.log`, which
contains all content logged at the error and critical levels. The names of these
log files are configurable in the "log" section of the config, as is the ability
to colorize the log level in the console. All of the logs are stored in a
directory called *log* at the top of the root directory.

## Lib Directory
Multiple, useful functions have been provided in the `app/lib` directory
which can be used across the code base and in plugins. Each of these files and
their content are documented below.

#### Auth
The `auth.js` file provides multiple functions for authenticating users. This
file is what allows for the multiple authentication modules, and exports a very
useful function `authenticate()`. This function can be used as middleware when
handling routes, and can require a user to be authenticated before accessing
specific route. Please see the end of section "5.0 Plugins" for an example of
using the authenticate function as route middleware.

#### Crypto
The `crypto.js` file provides multiple functions for handling encryption and
decryption. The most valuable functions here are `encrypt()` and `decrypt()`,
which use AES-256 encryption to encrypt and decrypt.

#### DB
The `db.js` file provides two functions, `connect()` and `disconnect()`, used 
for connecting and disconnecting from the database. If implementing your own
database rather than MongoDB, you will need to rewrite these functions to handle
connection to your other database.

#### Errors
`errors.js` exports the CustomError class. This class has been designed to
simplify error logging in MBEE. It is recommended to access this class through
the attached "M" Object. For example:
```javascript
const error = new M.CustomError('This is an error', 400, 'warn');
```
The CustomError has three parameters. The first is required, and is the error
message. The second is optional and is the HTTP status code. The third is also
optional, and is the log level of the error. If supplied, the error will be
logged (at the specified level) to the console.

#### Events
`events.js` exports an instance of a global event emitter. This event emitter is
used across the controllers when certain events occur. (users created, orgs
deleted, etc.) If a developer ever wishes to listen to these events (or emit
their own), this event emitter needs to be imported and used.

#### Get Public Data
The `get-public-data.js` exports functions used for parsing data directly from
the database, and returning it in a safe and clean format to the requesting
user. These functions are used in API routes. We recommend using them if
returning orgs, projects, elements or users from API calls.

#### JMI Conversions
The `jmi-conversions.js` exports functions used for converting model data
between different formats. There are three JMI formats, called JMI1, JMI2 and
JMI3. Throughout the code base, these formats are used specifically for
elements.

JMI1 is the simplest format, and the type of format returned by default. This is
an array of objects (generally element objects). This format is useful for
visualization and if the user desires to perform some operation on all elements.
```json
[
  {
    "id": "model",
    "name": "Model",
    "parent": "null",
    "contains": [
      "id": "elem1",
      "id": "elem2",
      "id": "elem3"
    ]
  },
  {
    "id": "elem1",
    "name": "Element 1",
    "parent": "model"
  },
  {
    "id": "elem2",
    "name": "Element 2",
    "parent": "model"
  },
  {
    "id": "elem3",
    "name": "Element 3",
    "parent": "elem1"
  }
]
```
JMI2 is a JSON object. Inside, for every item, there is a key/value pair where
the key is some unique identifier (generally the id) and the value is the
object (generally the element object). This format is useful for look-ups by
unique identifier as they are much faster than in arrays.
```json
{
  "model":
  {
    "name": "Model",
    "parent": "null",
    "contains": [
      "id": "elem1",
      "id": "elem2",
      "id": "elem3"
    ]
  },
  "elem1":
  {
    "id": "elem1"
    "name": "Element 1",
    "parent": "model"
  },
  "elem2":
  {
    "id": "elem2"
    "name": "Element 2",
    "parent": "model"
  },
  "elem3":
  {
    "id": "elem3",
    "name": "Element 3",
    "parent": "elem1"
  }
}
```
JMI3 is a combination of JMI2 and JMI1. JMI3 is an object, where the keys are
unique identifiers similar to JMI2. Where it differs is any child elements
are stored in their parents `contains` field. This creates a tree like structure
where the top level is the root, and the entire tree is stored in that objects
"contains" field. An example is below:

```json
{
  "model":
  {
    "name": "Model",
    "id": "model",
    "parent": "null",
    "contains":
    {
      "elem1":
      {
        "name": "Element 1",
        "id": "elem1",
        "parent": "model",
        "contains":
        {
          "elem3":
          {
            "name": "Element 3",
            "id": "elem3",
            "parent": "elem1",
            "contains": {}
          }
        }
      },
      "elem2":
      {
        "name": "Element 2",
        "id": "elem2",
        "parent": "model",
        "contains": {}
      }
    }
  }
}
```

#### Logger
The `logger.js` file exports the logger which is attached to the "M" object.
Similar to the CustomError class, it is recommended you use the logger directly
through the "M" object. Ex: `const err = M.log.warn('This is a warning');`

#### Middleware
The `middleware.js` file provides functions which can be used as middleware when
handling routes. These functions are used internally in the API routes
specifically to log the route and IP.

#### Migrate
`migrate.js` provides logic for handling and running database migrations. As
plugin developers, you will not need to touch this file.

#### Parse JSON
`parse-json.js` provides a single function, which is used to remove comments from
the `.cfg` files and return a JSON object.

#### Permissions
`permissions.js` provides functions for checking if users have permissions 
to perform a certain action. While not currently implemented, these functions will be add
to the controllers in a later release.

#### Sanitization
`sanitization.js` provides functions to sanitize against potentially malicious
user input. The two most used functions, `mongo()` and `html()`, are used to
sanitize database queries and rendered UI content respectively.

#### Startup
`startup.js` is run when the server is started, and prints the MBEE logo to the
console.

#### Test Utils
`test-utils.js` is a very useful file which provides functions used to
simplify unit testing. The file includes functions which create/delete test organizations, 
projects, admins and non-admins. These functions are used throughout the tests
in the `before()` and `after()` functions.

#### Utils
`utils.js` is the most used library across the code base. This file provides a
large number of random utility functions that can save time and lines of code.
The most used functions are listed below

- createID(...args)
  - Creates a concatenated ID which gets stored in the database. For example,
  the element ID which is actually stored in the database is a concatenation of
  the org, project, branch and element ID. This function takes any number of
  string arguments and concatenates them.
- parseID(id)
  - Splits the concatenated ID by it's delimiter (:) and returns an array of ids.
    (Ex. `org:proj:branch:elem` ->  `['org', 'proj', 'branch', 'elem']`)
- toTitleCase(string)
  - Capitalizes the first letter of the string.
  
#### Validators
`validators.js` provides a list of object validators. The validators can be
changed in the configuration to allow for stricter or laxer rules. These
validators are used when creating objects (orgs, projects, etc..) and if the
validation is not passed, the object cannot be created.

## Testing

#### Test Framework Overview

Tests will be executed in numeric order. To do this effectively, the following
naming conventions are used to number tests:

All tests will begin with a three digit number and will end with a letter. The
first two digits denote its category

- **0xx:** Reserved for initialization tasks. These should be used for any
  database initialization or other tasks to be done before all tests.
- **1xx:** Tests the test framework and basic infrastructure. These
  should be used to identify basic configuration issues like Mocha or Chai or
  to identify simple errors such as missing files.
- **2xx:** These should be used for unit tests of libraries and helpers. It can
  also be used for other basic tests that have few or no dependencies.
- **3xx:** These should be used for unit tests of data models.
- **4xx:** These should be used for controller tests.
- **5xx:** These should be used to test the API via mock requests. These tests
  do not require the server to be running.
- **6xx:** These should be used for API tests while running the MBEE server.
- **7xx:** These should be used for UI tests while running the MBEE server.
- **8xx:** These should be used for integration and system level tests.
- **9xx:** Reserved for wrap-up tasks to be used in conjunction
  with *0xx* initialization tasks.

The letter following the test number denotes which aspect of the module is being
tested. Currently, the trailing letters are only applied to the 3xx-6xx tests.

- **XXXa:** These tests ensure core functionality works. These test that when a
  function is run with valid input, the expected output is produced.
- **XXXb:** These tests ensure errors are thrown when invalid input is provided.
- **XXXc:** These tests check for any other expected functionality that is not
  core to a function. For example, one such test may ensure elements can be
  archived, which is not core to the `update()` function.
- **XXXd:** These tests check corner cases.

All tests will begin with a three digit number. The full name of the test,
seen by Mocha, should correspond to the name of the file.

> **How it works:** Mocha tests are a collection of `it` functions wrapped in
> a `describe` function. The first parameter passed to the describe function is
> the test name. We dynamically grab the name of the current file and pass
> that into the describe function. This ensures that the test name as seen by
> Mocha corresponds to the file name containing the test.

These test numbers are used both to uniquely identify the tests and to define
their order of execution.

#### Running Tests

Tests can be run by running the `node mbee test` command. Alternatively, this
can be done by running `node scripts/test`, `yarn run test`, or `npm test`.
Ultimately, this maps to a shell command that runs `mocha` and passes any
command line arguments to Mocha.

To run specific tests, you can pass in a regular expression via Mocha's `--grep`
flag. This regex will run only tests starting with that name. For example:

```bash
node mbee test --grep "^[0-4]"   # Runs tests 000 - 499
node mbee test --grep "^301"     # Runs test 301
node mbee test --grep "^6[0-2]"  # Runs tests 600-629
```

Any other Mocha arguments are valid to pass to the test command.

#### Writing Tests

Tests are written in the form of a *test module* which contains a collection
of tests. The test module must contain a single top-level `describe` function
(see [Mocha's Documentation](https://mochajs.org/#getting-started) for more
detail).

Each test module name should begin with a three-digit number which uniquely
identifies the test and determines the order in which it runs. That module
should be stored in the appropriately numbered directory within the test
directory.

Here are some guidelines for writing unit tests:

1. **Start with expected behavior.** Does the code do what it's supposed to do
when given valid input? Include a few test cases. For example: for a *User*
model. Make sure to add a user, delete a user, modify users, etc.
2. **Hit corner cases.** If there is unusual or unexpected input, make sure to
test it. For example: What if a user has a really long user name or email?
3. **Test invalid input.** Make sure it properly handles invalid input as you
would expect it to. For example: What if you try to add a user with an invalid
name or email? Or, what if you try to add a user that already exists?
4. **Leave the system in the state it started in.** Make sure the test suite
leaves the system in the same state it started in. For example if you added a
project, delete it. This allows unit tests to be written without knowledge of
other test suites or the order of test execution.

## Code Conventions and ESLint

While this isn't strictly a testing topic, it is a good practice that relates to
testing as it helps avoid inconsistencies or problems in the code base. We use
ESLint to maintain certain standards and conventions in our code.

You can start by simply running the linter by running `node mbee lint`. The
rule set for ESLint is defined in the [.eslintrc](.eslintrc) file and aligns with
our style guide.

We also recommend using EditorConfig. The [.editorconfig](.editorconfig) file
in the project's root directory will help enforce some of those style conventions.


