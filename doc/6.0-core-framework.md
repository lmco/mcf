# MBEE Core Framework

## Code Structure

MBEE is built using an MVC (Model/View/Controller) architecture. For those who
are not as familiar with this type of architecture, the code is divided up into
separate models (which house database schemas), controllers (which house code
for interacting with the models), and views (which house code for interacting
with objects created through the models and controllers).

Each primary component of the MBEE architecture has it's own model, view and
controller. For example, there is an element model, element controller and
element view.

#### Models

Models handle all data-related logic. In the case of MBEE, the models define
schemas and export them. Models are very similar to classes in normal
object-oriented programming. Models define a data structure which can be used as
a template to create a document. Models can additionally have functions
attached. In the case of the element model, functions such as
`getValidUpdateFields()` and `getValidPopulateFields()` are attached to the
model and can be called on an instance (document) of that model or can be
called using the model directly.

Each model also defines functions for interacting with the database. As we are
using mongoose, these functions are pre-defined for us and are exported
automatically with the model. You can read more about the mongoose model
functions in the [Mongoose documentation](https://mongoosejs.com/docs/guide.html).

#### Controllers

Controllers interact with the model directly, and define CRUD operations which
get used in the views. Each controller imports it's respective model, and uses
that model to manipulate data. Each controller in MBEE defines functions for
finding, creating, replacing, updating and deleting documents from the database.
The controllers preform additional logic on top of the data to confirm validity.
For example, the element controller preforms logic on delete that ensures the
user is not trying to delete the root model element.

#### Views

Views are UI components that directly interact with models and controllers,
usually through an API. In the case of MBEE, the views can API functions which
in turn call controller functions, which use the models to manipulate data.

## The "M" Object

The M object is a global object which is accessible across the entire code base.
It contains valuable information and operations which are easier to attach to
the object, rather than import in every location needed. The M object is created
upon server startup, and is locked from modification immediately, so do not
attempt to change fields or add your own. The following information is provided
in the M object and is accessible any place in the root directory (including
plugins).

- **env:** Provides the current running environment (as a string). If no
  environment was specified upon startup, the *default* environment is used.
- **version:** Provides the current version of MBEE. This value can be found in
  the package.json.
- **build:** Provides the build number found in the package.json. If none is
  specified, it defaults to *NO_BUILD_NUMBER*.
- **schemaVersion:** Provides the schemaVersion, found in the package.json.
- **require():** Provides a simplified function for importing files within the
  */app* directory. This can be used by providing the path AFTER app, and
  separating the directories using dot notation.
  Ex: `const Element = M.require('models.element');`
- **getModuleName():** Provides a function which returns the module name.
- **root:** Provides a path to the root directory. This can be used to access
  files within the root directory, no matter where that directory is located.
- **config:** Provides an object which contains all key/value pairs from the
  running config.
- **log():** Provides a function for logging information to the console. Can
  also be used to log information and errors to .log files. See the log section
  below for more information.
- **CustomError():** Provides access to the CustomError class. CustomErrors are
  used throughout the code to organize errors. The CustomError constructor
  expects three parameters, the error message, HTTP status code and log level.

## Logger

Built into the global M object is a very useful logger. It has the ability to
print information to the console at different log levels (and colors), as well
as log information to .log files. There are 6 log levels, listed in order from
least important to most important: debug, verbose, info, warn, error, and
critical. If we wanted to log some information to the console, we could
simply do it by calling `M.log.info('Your info here');`.

There are three .log files created by default, each of which contain different
information. The first is `mbee-debug.log`. This file contains anything and
everything which has been logged. The next file is `mbee.log`, which contains
anything that has been logged at or above the level specified in the log.level
section of the running config. The final log file is `mbee-error.log`, which
contains all content logged at the error and critical levels. The names of these
log files are configurable in the "log" section of the config, as is the ability
to colorize the log level in the console. All of the logs are stored in a
directory called *log* at the top of the root directory.

## Testing

#### Test Framework Overview

Tests will be executed in numeric order. To do this effectively, the following
naming conventions are used to number tests:

All tests will begin with a three digit number and will end with a letter. The
first two digits denote its category

- **0xx:** Reserved for initialization tasks. These should be used for any
  database initialization or other tasks to be done before all tests.
- **1xx:** Tests the test framework and basic infrastructure. These
  should be used to identify basic configuration issues like Mocha or Chai or
  to identify simple errors such as a missing files.
- **2xx:** These should be used for unit tests of libraries and helpers. It can
  also be used for other basic tests that have few or no dependencies.
- **3xx:** These should be used for unit tests of data models.
- **4xx:** These should be used for controller tests.
- **5xx:** These should be used to test the API via mock requests.
- **6xx:** These should be used for API tests while running the MBEE server.
- **7xx:** These should be used for UI tests while running the MBEE server.
- **8xx:** These should be used for integration and system level tests.
- **9xx:** Reserved for wrap-up tasks to be used in conjunction
  with *0xx* initialization tasks.

The letter following the test number denotes which aspect of the module is being
tested. Currently, the trailing letters are only applied to the 3xx-6xx tests.

- **XXXa:** These tests ensure core functionality works. These test that when a
  function is run with valid input, the expected output is produced.
- **XXXb:** These tests ensure errors are thrown when invalid input is provided.
- **XXXc:** These tests check for any other expected functionality that is not
  core to a function. For example, one such test may ensure elements can be
  archived, which is not core to the `update()` function.
- **XXXd:** These tests check corner cases. While none are currently written
  this letter is reserved for these tests.

All tests will begin with a three digit number. The full name of the test,
seen by Mocha, should correspond to the name of the file.

> **How it works:** Mocha tests are a collection of `it` functions wrapped in
> a `describe` function. The first parameter passed to the describe function is
> the test name. We dynamically grab the file name of the current file and pass
> that into the describe function. This ensures that the test name as seen by
> Mocha corresponds to the file name containing the test.

These test numbers are used both to uniquely identify the tests and to define
their order of execution.

#### Running Tests

Tests can be run by running the `node mbee test` command. Alternatively, this
can be done by running `node scripts/test`, `yarn run test`, or `npm test`.
Ultimately, this maps to a shell command that runs `mocha` and passes any
command line arguments to Mocha.

To run specific tests, you can pass in a regular expression via Mocha's `--grep`
flag. This regex will run only tests starting with that name. For example:

```
node mbee test --grep "^[0-4]"   # Runs tests 000 - 499
node mbee test --grep "^301"     # Runs test 301
node mbee test --grep "^6[0-2]"  # Runs tests 600-629
```

Any other Mocha arguments are valid to pass to the test command.

#### Writing Tests

Tests are written in the form of a *test module* which contains a collection
of tests. The test module must contain a single top-level `describe` function
(see [Mocha's Documentation](https://mochajs.org/#getting-started) for more
detail).

Each test module name should begin with a three-digit number which uniquely
identifies the test and determines the order in which it runs. That module
should be stored in the appropriately numbered directory within the test
directory.

Here are some guidelines for writing unit tests:

1. **Start with expected behavior.** Does the code do what it's supposed to do
when given valid input? Include a few test cases. For example: for a *User*
model. Make sure to add a user, delete a user, modify users, etc.
2. **Hit corner cases.** If there is unusual or unexpected input, make sure to
test it. For example: What if a user has a really long user name or email?
3. **Test invalid input.** Make sure it properly handles invalid input as you
would expect it to. For example: What if you try to add a user with an invalid
name or email? Or, what if you try to add a user that already exists?
4. **Leave the system in the state it started in.** Make sure the test suite
leaves the system in the same state it started in. For example if you added a
project, delete it. This allows unit tests to be written without knowledge of
other test suites or the order of test execution.

## Code Conventions and ESLint

While this isn't strictly a testing topic, it is a good practice that relates to
testing as it helps avoid inconsistencies or problems in the code base. We use
ESLint to maintain certain standards and conventions in our code.

You can start by simply running the linter by running `node mbee lint`. The
rule set for ESLint is defined in the [.eslintrc](.eslintrc) file and aligns with
our style guide.

We also recommend using EditorConfig. The [.editorconfig](.editorconfig) file
in the project's root directory will help enforce some of those style conventions.


